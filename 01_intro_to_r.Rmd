---
title: "Знакомство с R"
subtitle: "Математические методы"
author: 
  - Вадим Хайтов
  - Марина Варфоломеева
  - Анастасия Лянгузова
output: ioslides_presentation
css: assets/my_styles.css
---

```{r setup, include = FALSE, cache = FALSE, purl = FALSE, fig.showtext = TRUE}
source("assets/xaringan_setup.R")
library(xaringanExtra)
use_tile_view()
use_scribble()
use_search(show_icon = FALSE)
use_progress_bar(color = "#6d2b5e", location = "bottom", height = "10px")
use_freezeframe()
# use_webcam()
# use_panelset()
# use_extra_styles(hover_code_line = TRUE)

# http://tachyons.io/docs/
# https://roperzh.github.io/tachyons-cheatsheet/
use_tachyons()
```

<!-- class: middle, center, inverse -->

# Знакомство с R



## Загрузка, установка...

Собственно, сам [R](https://cran.r-project.org/)

[RStudio](posit.co)  среда для разработки (IDE) на R

Онлайн IDE для R  на тот случай, если у вас не установлен R:

-   <https://posit.cloud>




1.  Создайте папку (например *"mat_met"*), где будут храниться ВСЕ материалы курса. Эта папка будет **рабочей директорией**. В эту папку помещайте ВСЕ файлы с кодом (с расширением .R).

2.  Внутри папки `mat_met` создайте папку `data`, где будут храниться все файлы с данными для анализа.

В итоге у вас должно получиться примерно это:

    C:\mat_met\
    C:\mat_met\data\
    


## Установка рабочей директории

Есть несколько способов установки пути к рабочей директории:

1. Выберите в меню `Session -> Set working Directory... -> To Source File Location` (Если вы уже сохранили код).

2. На вкладке `Files` в одной из рабочих областей RStudio выберите многоточие `...` -> в открывшемся системном диалоге выбора файлов найдите директорию, в которой лежит ваш код и нажмите OK

3. Можно вручную прописать путь к рабочей директории в кавычках в качестве аргумента функции `setwd()`

```{r eval=FALSE}

setwd("~/linmodr")

```

Полезно создать в рабочей директории проект в формате `.Rproj` и работать, запуская проект. 



## Как получить помощь

1.  В RStudio можно поставить курсор на имя функции, например `setwd()`, и нажать `F1`
2.  Перед названием функции можно напечатать знак вопроса и выполнить эту строку `?setwd`
3.  Можно воспользоваться функцией `help()`

```{r eval=FALSE}
help("setwd")
```



## Настройка RStudio

Все настройки RStudio находятся в меню Tools -\> Global Options

-   Восстановление рабочего пространства из прошлого сеанса  это лучше отменить, т.к. обычно переменные-призраки очень мешают. На вкладке `General` убираем галочку `Restore .RData into workspace at startup`, и меняем `Save workspace to .RData on exit` на `Never`
-   Перенос длинных строк в окне кода  это удобно. На вкладке `Code` ставим галочку рядом с опцией `Soft-wrap R source files`.

## Комментарии

Комментарии в текстах программ обозначаются символом \#

```{r}
# это комментарии, они не будут выполняться
```



## Полезные клавиатурные сокращения в RStudio

-   `Ctrl + Shift + C`  закомментировать/раскомментировать выделенный фрагмент кода.
-   `Ctrl + Enter`  отправляет активную строку из текстового редактора в консоль, а если выделить несколько строк, то будет выполнен этот фрагмент кода.
-   `Ctrl + Alt`  выбор нескольких строк одновременно.
-   `Tab` или `Ctrl + Space`  нажмите после того как начали набирать название функции или переменной, и появится список автоподстановки. Это помогает печатать код быстро и с меньшим количеством ошибок.
-   `Ctrl + L`  очистить консоль. 
-   `Alt + -`  ввод оператора присваивания (`<-`).
-   `Ctrl + Shift + M`  ввод оператора `%>%` (pipe operator).




## R как калькулятор, математические операции

```{r}
2+2
1024/2
1:10
34*4
2^4
sqrt(27)
```



## Переменные

Оператор присваивания это символ стрелочки `<-`. Он работает справа налево, это значит, что значение выражения в его правой части присваивается объекту в левой части.

Переменные  это такие контейнеры, в которые можно положить разные данные и даже функции.

Имена переменных могут содержать латинские буквы обоих регистров, символы точки . и подчеркивания \_ , а также цифры. Имена переменных должны начинаться с латинских букв. Создавайте понятные и "говорящие" имена переменных.

```{r}
var_1 <- 1024 / 2
1238 * 3 -> var_2
var_2
```

Как выбрать название переменной?

-   `a` - плохо, и даже `b`, `с`, или `х`. Но в некоторых случаях допустимо:)
-   `var1` - плохо, но уже лучше
-   `var_1` - плохо, но уже лучше
-   `braincontent` - говорящее, но плохо читается
-   `brain_content`, `BrainContent` или `brain.content` - хорошие говорящие и читабельные названия



## Векторы 

Данные в R можно хранить в виде разных объектов. R  векторный язык, и большинство объектов в нём представлены векторами. 

Векторы бывают:

- атомарные  все элементы представлены одним типом данных; 
- списки  могут быть разные типы данных.

Примеры атомарных векторов:

```{r}
23
sqrt(25)
```

Полученные величины  просто векторы единичной длины.

*Вектор* -- один объект, внутри которого несколько значений.



## Некоторые способы создания векторов:

-   Оператор `:` используется для создания целочисленных векторов, где значения следуют одно за другим без пропусков

```{r}
1:10 # от одного до 10
-5:3 # от -5 до 3
```

-   Функция `seq()` создает последовательности из чисел

```{r}
seq(from = 1, to = 5, by = 0.5)
```



## Некоторые способы создания векторов

-   Функция `c()` - от англ. concatenate. Следите, чтобы было английское си, а не русское эс:).

```{r eval=FALSE}
?c # посмотрите хелп к функции
```

Функция `c` принимает несколько (произвольное количество) аргументов, разделенных запятыми. Она собирает из них вектор.

```{r}
c(2, 4, 6)
c(-9.3, 0, 2.17, 21.3)
```

Векторы можно хранить в переменных для последующего использования

```{r}
vect_num <- -11:12 # численный вектор от -11 до 12 сохранен в переменной vect_num
vect_num_1 <- c(1.3, 1.7, 1.2, 0.9, 1.6, 1.4) # численный вектор, сохранен в переменной vect_num_1
```



## Адресация внутри векторов

При помощи оператора `[]`, можно обратится к некоторым элементам вектора. В квадратных скобках вам нужно указать один или несколько порядковых номеров элементов

```{r}
vect_num[1] # первый элемент в векторе vect_num
vect_num[10] # 10-й элемент
vect_num[22]
```

Если вам нужно несколько элементов, то их нужно передать квадратным скобкам в виде вектора. Например, нам нужны элементы с 3 по 5. Вот вектор, который содержит значения 3, 4 и 5.

```{r}
3:5
```

Если мы его напишем в квадратных скобках, то добудем элементы с такими порядковыми номерами

```{r}
vect_num[3:5]
```



## Выбор элементов из вектора

Аналогично, если вам нужны элементы не подряд, то передайте вектор с номерами элементов, который вы создали при помощи функции c() c(2, 4, 6) \# это вектор содержащий 2, 4 и 6, поэтому

```{r}
vect_num[c(2, 4, 6)] # возвращает 2-й, 4-й и 6-й элементы
vect_num[c(1, 10, 20)] # возвращает 1-й, 10-й и 20-й элементы
```

Вектор - одномерный объект. У его элементов только один порядковый номер (индекс). Поэтому при обращении к элементам вектора нужно указывать только одно число или один вектор с адресами.

Правильно:

```{r}
vect_num[c(1, 2, 5)] # возвращает 1-й, 3-й и 5-й элементы
```



## Выбор элементов из вектора

R выдаёт ошибку, если при обращении к вектору просто перечислить номера элементов через запятую.

```{r eval=FALSE}
vect_num[1, 3, 5] # ошибка
vect_num[15, 9, 1] # ошибка
```

```{r}
vect_num[c(15, 9, 1)] # правильно
```

При помощи функции c() можно объединять несколько векторов в один вектор

```{r}
c(1, 1, 5:9)
c(vect_num, vect_num)
c(100, vect_num)
```

Добываем 1, 3, 5 и с 22 по 24 элементы

```{r}
vect_num[c(1, 3, 5, 22:24)]
```



class: middle, center, inverse

# Типы данных в R



## Числовые данные

Всё, что вы видели в прошлом разделе :)



## Текстовые данные

Каждый текстовый элемент (говорят "строка" - string или character) должен быть окружен кавычками  двойными или одинарными.

```{r}
"это текст"
'это тоже текст'
```

Текстовые значения можно объединять в вектора. Так получается текстовый вектор.

```{r}
rainbow <- c("red", "orange", "yellow", "green", "blue", "violet")
rainbow # весь вектор
```



## Объединение векторов

Добываем первый и последний элементы.

Точно знаем, что элементов 6 в данном случае.

```{r}
rainbow[c(1, 6)]
```

Добываем элементы с 3 по 6.

Если у вас вдруг слишком короткий вектор в этом задании, то можно склеить новый из двух.

```{r}
double_rainbow <- c(rainbow, rainbow)
double_rainbow
rainbow[3:6] # элементы с 3 по 6
```



## Логические данные

```{r}
TRUE # истина
FALSE # ложь
```

Можно сокращать первыми заглавными буквами. **Но лучше так не делать**, чтобы читать программы было легче.

```{r}
c(T, T, T, T, F, F, T, T)
```

Создаём логический вектор.

```{r}
c(TRUE, TRUE, TRUE, FALSE, FALSE, TRUE)
```

Ещё логический вектор

```{r}
short_logical_vector <- c(FALSE, TRUE)
```



## Длинные векторы

Чтобы создавать длинные вектора из повторяющихся элементов, можно использовать функцию rep().

```{r}
rep(x = 1, times = 3) # 1 повторяется 3 раза
rep(x = "red", times = 5) # "red" повторяется 5 раз
rep(x = TRUE, times = 2) # TRUE повторяется 2 раза
```



## Аргументы функций 

В R названия аргументов функций можно не указывать, если вы используете аргументы порядке, прописанном в help к этой функции.

```{r}
rep(TRUE, 5) # TRUE повторяется 5 раз, аргументы без названий
```

Создаем логический вектор, где TRUE повторяется 3 раза, FALSE 3 раза и TRUE 4 раза. Результат сохраняем в переменной vect_log

```{r}
vect_log <- c(rep(TRUE, 3), rep(FALSE, 3), rep(TRUE, 4))
vect_log
```



## Применение логических векторов для фильтрации данных

Логические векторы создаются при проверке выполнения каких-либо условий, заданных при помощи логических операторов (`>`, `<`, `==`, `!=`, `>=`, `<=`, `!`, `&`, `|`). Такие векторы можно использовать для фильтрации данных.

Вспомните, у нас был вот такой текстовый вектор.

```{r}
double_rainbow
```



## Задача 1. 

Извлекаем только .yellow[жёлтый] цвет.

Мы можем создать логический вектор, в котором TRUE будет только для 3-го и 9-го элементов.

```{r}
f_yellow <- double_rainbow == "yellow"
f_yellow
```

Этот логический вектор-фильтр мы можем использовать для извлечения данных из `double_rainbow`

```{r}
double_rainbow[f_yellow]
```



## Задача 2. 

Извлекаем из double_rainbow .yellow[жёлтый] и .blue[синий]. Жёлтый фильтр у нас уже есть, поэтому мы создадим фильтр для синего.

```{r}
f_blue <- double_rainbow == "blue"
```

Выражение "жёлтый или синий" можно записать при помощи логического "или" (`|`)

```{r}
f_yellow | f_blue
```

Задача решена, мы извлекли жёлтый и синий цвета.

```{r}
double_rainbow[f_yellow | f_blue]
```



## Сокращаем запись

То же самое можно было бы записать короче.

В одну строку  совершенно нечитабельно:

```{r}
double_rainbow[double_rainbow == "yellow" | double_rainbow == "blue"]
```

Фильтр отдельно  читается лучше:

```{r}
f_colours <- double_rainbow == "yellow" | double_rainbow == "blue"
double_rainbow[f_colours]
```



## Задача 3

Был числовой вектор.

```{r}
vect_num
```

Извлекаем из числового вектора `vect_num` только значения больше 0.

```{r}
vect_num[vect_num > 0]
```

**Задача 4**. Давайте извлечем из вектора `vect_num` все числа, которые либо меньше или равны -8, либо больше или равны 8

```{r}
f_5_8 <- (vect_num <= -8) | (vect_num >= 8)
vect_num[f_5_8]
```



## Факторы

Факторы  это способ хранения дискретных (= категориальных данных). Факторы построены на основе целочисленных векторов и имеют несколько атрибутов (`class` и `level`).

Например, если вы поймали 10 улиток и посмотрели их цвет. У большого количества улиток небольшое счетное количество возможных цветов.

```{r}
snail_colours <- c("red", "green", "green", "green", "yellow", "yellow", "yellow", "yellow")
snail_colours # это текстовый вектор
```

Цвет "жёлтый" обозначает одно и то же для каждой из улиток. Поэтому в целях экономии места можно записать цвета этих улиток в виде вектора, в котором численным значениям будут сопоставлены "этикетки" (называются "уровни", levels)  названия цветов. Мы можем создать фактор "цвет улиток".



## Создаём фактор 

```{r}
factor(snail_colours)
```

уровни этого фактора

-   1  green,
-   2  red,
-   3  yellow.

По умолчанию, R назначает порядок уровней по алфавиту. Можно изменить порядок (см. `help("factor")`). Нам это пригодится позже.

```{r}
double_rainbow # текстовый вектор
```

Создаем фактор из текстового вектора и складываем его в переменную

```{r}
f_double_rainbow <- factor(double_rainbow)
```



## Как узнать, что за данные хранятся в переменной?

Чтобы узнать, что за данные хранятся в переменной, используйте функцию `class()`

```{r}
class(f_double_rainbow)
class(vect_log)
class(vect_num)
class(rainbow)
```



## Встроенные константы в R

Встроенные константы в R: NA, NULL, NAN, Inf

-   NA -- англ "not available". Когда объект был, но его свойство не измерили или не записали.
-   NULL -- пусто - просто ничего нет
-   NaN -- "not a number"
-   Inf -- "infinity" - бесконечность

Вот текстовый вектор с пропущенным значением

```{r}
rainbow_1 <- c("red", "orange", NA, "green", "blue", "violet")
```



Что будет, если попытаться добыть из вектор номер элемента, которого там нет? 

--

R выдаст NA, потому, что такого элемента нет.

```{r}
rainbow_1[198]
```



## Арифметические операции с векторами

```{r}
vect_num

vect_num + 2
vect_num * 2
vect_num * (-2)
vect_num^2
```



## Операции с векторами, содержащими константы

```{r}
NAs_NANs <- c(1, 3, NA, 7, 0, 22:24)
```

Что произойдет с NA?

```{r}
NAs_NANs + 2 # останется NA
NAs_NANs * 0 # останется NA
NAs_NANs / 0  # останется NA
```

*Но в последнем случае вы увидите:*

-   Inf при делении чисел на ноль;
-   NaN при делении нуля на ноль.

NaN получится, если взять корень из отрицательного числа

```{r}
sqrt(-1)
```



## Функции в R

Вы уже видели массу функций, их легко узнать по скобкам после ключевого слова. Познакомимся еще с несколькими и научимся писать пользовательские функции. Пользовательские функции позволяют автоматизировать повторяющиеся действия и делают код легко читаемым.

Вот наш вектор

```{r}
NAs_NANs
```

Длину вектора можно вычислить при помощи функции `length()`

```{r}
length(NAs_NANs)
```

Сумму элементов вектора при помощи функции `sum()`

```{r}
sum(NAs_NANs)
```

Упс! Почему-то получилось `NA`.



## Работа функций с векторами, содержащими константы

У функции `sum()` есть аргумент `na.rm`, который по умолчанию принимает значение `FALSE`, то есть `NA` не учитываются при подсчете суммы.

Если мы передадим функции `sum` аргумент `na.rm = TRUE`, то получится правильная сумма

```{r}
sum(NAs_NANs, na.rm = TRUE)
```

Та же история с функцией `mean`

```{r}
mean(NAs_NANs, na.rm = TRUE)
```



## Пользовательские функции

Попробуем написать пользовательскую функцию `mmean()`, которая будет по умолчанию считать среднее значение элементов в векторе с учетом пропущенных значений (`NA`)

```{r}
mmean <- function(x){
  mean(x, na.rm = TRUE)
  }
```

В этом коде: - mmean - переменная, название функции. В эту переменную мы складываем функцию, которую создает функция `function()`  функция, которая делает функции. В скобках перечисляются аргументы (названия переменных, которые мы передаем в функцию, чтобы она что-то сделала с ними) - `{ }` - в фигурных скобках тело функции - последовательность действий, которую нужно сделать с аргументами



## Return в теле функции

У больших функций бывает еще инструкция `return()`, которая сообщает, что именно должна возвращать наша функция. Вот как выглядела бы наша функция с этой инструкцией.

```{r}
mmean <- function(x){
  res <- mean(x, na.rm = TRUE)
  return(res)
}
```

Проверим нашу функцию при помощи встроенной функции

```{r}
mean(vect_num, na.rm = TRUE)
mmean(vect_num)
```



## Матрицы 

Матрицы  двумерный объект, схожий с атомарными векторами, но содержащий дополнительный аттрибут `dim`. 

Матрицу можно создать следующим образом:

```{r}
matrix(1:9, nrow = 3, ncol = 3)
```

Размерность матрицы создаётся двумя аргументами: `nrow` (количество строк) и `ncol` (количество столбцов). 



## Датафреймы  двумерные структуры данных

Датафрейм  один из способов хранения табличных данных в R.  Строится на базе списков и имеет в т.ч. сходные с матрицами свойства. Имеет такие атрибуты как `rownames` (имена строк) и `colnames` (имена столбцов). `names` датафрейма идентичны `colnames`. 

Создадим датафрейм. Для начала создадим векторы с данными для переменных.

```{r}
len <- 1:9 # числовой
col <- c(rep("green", 4), rep("red", 5)) # текстовый
wid <- seq(from = 2, by = 2, to = 18) # числовой
```

Теперь сложим эти векторы в датафрейм

```{r}
my_worms <- data.frame(Length = len, Width = wid, Colour = col, stringsAsFactors = TRUE)
```

Можно проверить, действительно мы создали объект класса data.frame

```{r}
class(my_worms) # смотрим, действительно датафрейм
```



## Превращение других типов данных в датафрейм

Например, из матрицы...

```{r}
mat <- matrix(1:9, nrow = 3, ncol = 3)
mat_data <- as.data.frame(mat)
str(mat_data)
```



## Содержимое датафрейма

Содержимое датафрейма можно посмотреть несколькими способами.

```{r results='hide'}
my_worms # печать датафрейма
View(my_worms) # просмотр в RStudio
head(my_worms)
tail(my_worms)
# fix(my_worms) # ручное редактирование. осторожно! избегайте его использовать, никаких документов о нем не останется
```

Также у датафрейма можно посмотреть количество строк и столбцов.

```{r}
nrow(my_worms)
ncol(my_worms)
length(my_worms) #выдаст количество столбцов
```



## Адресация внутри датафреймов

Вывод столбца-переменной при помощи оператора \$ и имени переменной

```{r}
my_worms$Length
my_worms$Width
```

У каждой ячейки в датафрейме есть координаты вида [строка, столбец]

```{r}
my_worms[2, 3] # вторая строка в 3 столбце
my_worms[2, ] # вторая строка целиком
my_worms[1:9, 2] # строки с 1 по 9 во втором столбце
my_worms[, 2] # второй столбец целиком
```



## Расширение датафрейма

Добавление колонки.

```{r}
my_worms$Site <- c("Sredniy", "Sredniy", "Ogorod", "Vichennaya", "Ogorod", "Vichennaya", "Keret", "Ogorod", "Vichennaya")
my_worms
```



## Добавление строки

```{r}
my_worms_new <- data.frame(Length = 40, Width = 60, Colour = "blue", Site = "Pashinnikov")
my_worms_final <- rbind(my_worms, my_worms_new)
my_worms_final
```

