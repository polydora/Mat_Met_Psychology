<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Знакомство с R</title>
    <meta charset="utf-8" />
    <meta name="author" content="Марина Варфоломеева" />
    <meta name="author" content="Анастасия Лянгузова" />
    <meta name="author" content="Вадим Хайтов" />
    <script src="libs/header-attrs-2.20/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/tamu-fonts.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/ninjutsu.css" rel="stylesheet" />
    <link href="libs/tile-view-0.2.6/tile-view.css" rel="stylesheet" />
    <script src="libs/tile-view-0.2.6/tile-view.js"></script>
    <script src="libs/fabric-4.3.1/fabric.min.js"></script>
    <link href="libs/xaringanExtra-scribble-0.0.1/scribble.css" rel="stylesheet" />
    <script src="libs/xaringanExtra-scribble-0.0.1/scribble.js"></script>
    <script>document.addEventListener('DOMContentLoaded', function() { window.xeScribble = new Scribble({"pen_color":["#FF0000"],"pen_size":3,"eraser_size":30,"palette":[]}) })</script>
    <script src="libs/mark.js-8.11.1/mark.min.js"></script>
    <link href="libs/xaringanExtra-search-0.0.1/search.css" rel="stylesheet" />
    <script src="libs/xaringanExtra-search-0.0.1/search.js"></script>
    <script>window.addEventListener('load', function() { window.xeSearch = new RemarkSearch({"position":"bottom-left","caseSensitive":false,"showIcon":false,"autoSearch":true}) })</script>
    <script src="libs/xaringanExtra-progressBar-0.0.1/progress-bar.js"></script>
    <script src="libs/freezeframe-5.0.2/freezeframe.min.js"></script>
    <script src="libs/xaringanExtra-freezeframe-0.0.1/freezeframe-init.js"></script>
    <script id="xaringanExtra-freezeframe-options" type="application/json">{"selector":"img[src$=\"gif\"]","trigger":"click","overlay":false,"responsive":true,"warnings":true}</script>
    <link href="libs/tachyons-4.12.0/tachyons.min.css" rel="stylesheet" />
    <!-- https://github.com/fnaufel/xaringan-smartify-->
    <script
    			  src="https://code.jquery.com/jquery-3.4.1.slim.min.js"
    			  integrity="sha256-pasqAKBDmFT4eHoN2ndd6lN370kFiGUFyTiUHWhU7k8="
    			  crossorigin="anonymous">
    </script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/fnaufel/xaringan-smartify/smartify.min.js"></script>
    <link rel="stylesheet" href="assets/xaringan-themer.css" type="text/css" />
    <link rel="stylesheet" href="assets/xaringan.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: middle, left, inverse, title-slide

.title[
# Знакомство с R
]
.subtitle[
## Математические методы
]
.author[
### Марина Варфоломеева
]
.author[
### Анастасия Лянгузова
]
.author[
### Вадим Хайтов
]

---




class: middle, center, inverse

# Знакомство с R

---

## Загрузка, установка...

Собственно, сам [R](https://cran.r-project.org/)

[RStudio](posit.co) --- среда для разработки (IDE) на R

Онлайн IDE для R --- на тот случай, если у вас не установлен R:

-   &lt;https://posit.cloud&gt;


---

1.  Создайте папку (например *"mat_met"*), где будут храниться ВСЕ материалы курса. Эта папка будет **рабочей директорией**. В эту папку помещайте ВСЕ файлы с кодом (с расширением .R).

2.  Внутри папки `mat_met` создайте папку `data`, где будут храниться все файлы с данными для анализа.

В итоге у вас должно получиться примерно это:

    C:\mat_met\
    C:\mat_met\data\
    
---

## Установка рабочей директории

Есть несколько способов установки пути к рабочей директории:

1. Выберите в меню `Session -&gt; Set working Directory... -&gt; To Source File Location` (Если вы уже сохранили код).

2. На вкладке `Files` в одной из рабочих областей RStudio выберите многоточие `...` -&gt; в открывшемся системном диалоге выбора файлов найдите директорию, в которой лежит ваш код и нажмите OK

3. Можно вручную прописать путь к рабочей директории в кавычках в качестве аргумента функции `setwd()`


```r
setwd("~/linmodr")
```

Полезно создать в рабочей директории проект в формате `.Rproj` и работать, запуская проект. 

---

## Как получить помощь

1.  В RStudio можно поставить курсор на имя функции, например `setwd()`, и нажать `F1`
2.  Перед названием функции можно напечатать знак вопроса и выполнить эту строку `?setwd`
3.  Можно воспользоваться функцией `help()`


```r
help("setwd")
```

---

## Настройка RStudio

Все настройки RStudio находятся в меню Tools -\&gt; Global Options

-   Восстановление рабочего пространства из прошлого сеанса --- это лучше отменить, т.к. обычно переменные-призраки очень мешают. На вкладке `General` убираем галочку `Restore .RData into workspace at startup`, и меняем `Save workspace to .RData on exit` на `Never`
-   Перенос длинных строк в окне кода --- это удобно. На вкладке `Code` ставим галочку рядом с опцией `Soft-wrap R source files`.

## Комментарии

Комментарии в текстах программ обозначаются символом \#


```r
# это комментарии, они не будут выполняться
```

---

## Полезные клавиатурные сокращения в RStudio

-   `Ctrl + Shift + C` --- закомментировать/раскомментировать выделенный фрагмент кода.
-   `Ctrl + Enter` --- отправляет активную строку из текстового редактора в консоль, а если выделить несколько строк, то будет выполнен этот фрагмент кода.
-   `Ctrl + Alt` --- выбор нескольких строк одновременно.
-   `Tab` или `Ctrl + Space` --- нажмите после того как начали набирать название функции или переменной, и появится список автоподстановки. Это помогает печатать код быстро и с меньшим количеством ошибок.
-   `Ctrl + L` --- очистить консоль. 
-   `Alt + -` --- ввод оператора присваивания (`&lt;-`).
-   `Ctrl + Shift + M` --- ввод оператора `%&gt;%` (pipe operator).


---

## R как калькулятор, математические операции


```r
2+2
```

```
[1] 4
```

```r
1024/2
```

```
[1] 512
```

```r
1:10
```

```
 [1]  1  2  3  4  5  6  7  8  9 10
```

```r
34*4
```

```
[1] 136
```

```r
2^4
```

```
[1] 16
```

```r
sqrt(27)
```

```
[1] 5.196
```

---

## Переменные

Оператор присваивания это символ стрелочки `&lt;-`. Он работает справа налево, это значит, что значение выражения в его правой части присваивается объекту в левой части.

Переменные --- это такие контейнеры, в которые можно положить разные данные и даже функции.

Имена переменных могут содержать латинские буквы обоих регистров, символы точки . и подчеркивания \_ , а также цифры. Имена переменных должны начинаться с латинских букв. Создавайте понятные и "говорящие" имена переменных.


```r
var_1 &lt;- 1024 / 2
1238 * 3 -&gt; var_2
var_2
```

```
[1] 3714
```

Как выбрать название переменной?

-   `a` - плохо, и даже `b`, `с`, или `х`. Но в некоторых случаях допустимо:)
-   `var1` - плохо, но уже лучше
-   `var_1` - плохо, но уже лучше
-   `braincontent` - говорящее, но плохо читается
-   `brain_content`, `BrainContent` или `brain.content` - хорошие говорящие и читабельные названия

---

## Векторы 

Данные в R можно хранить в виде разных объектов. R --- векторный язык, и большинство объектов в нём представлены векторами. 

Векторы бывают:

- атомарные --- все элементы представлены одним типом данных; 
- списки --- могут быть разные типы данных.

Примеры атомарных векторов:


```r
23
```

```
[1] 23
```

```r
sqrt(25)
```

```
[1] 5
```

Полученные величины --- просто векторы единичной длины.

*Вектор* -- один объект, внутри которого несколько значений.

---

## Некоторые способы создания векторов:

-   Оператор `:` используется для создания целочисленных векторов, где значения следуют одно за другим без пропусков


```r
1:10 # от одного до 10
```

```
 [1]  1  2  3  4  5  6  7  8  9 10
```

```r
-5:3 # от -5 до 3
```

```
[1] -5 -4 -3 -2 -1  0  1  2  3
```

-   Функция `seq()` создает последовательности из чисел


```r
seq(from = 1, to = 5, by = 0.5)
```

```
[1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0
```

---

## Некоторые способы создания векторов

-   Функция `c()` - от англ. concatenate. Следите, чтобы было английское си, а не русское эс:).


```r
?c # посмотрите хелп к функции
```

Функция `c` принимает несколько (произвольное количество) аргументов, разделенных запятыми. Она собирает из них вектор.


```r
c(2, 4, 6)
```

```
[1] 2 4 6
```

```r
c(-9.3, 0, 2.17, 21.3)
```

```
[1] -9.30  0.00  2.17 21.30
```

Векторы можно хранить в переменных для последующего использования


```r
vect_num &lt;- -11:12 # численный вектор от -11 до 12 сохранен в переменной vect_num
vect_num_1 &lt;- c(1.3, 1.7, 1.2, 0.9, 1.6, 1.4) # численный вектор, сохранен в переменной vect_num_1
```

---

## Адресация внутри векторов

При помощи оператора `[]`, можно обратится к некоторым элементам вектора. В квадратных скобках вам нужно указать один или несколько порядковых номеров элементов


```r
vect_num[1] # первый элемент в векторе vect_num
```

```
[1] -11
```

```r
vect_num[10] # 10-й элемент
```

```
[1] -2
```

```r
vect_num[22]
```

```
[1] 10
```

Если вам нужно несколько элементов, то их нужно передать квадратным скобкам в виде вектора. Например, нам нужны элементы с 3 по 5. Вот вектор, который содержит значения 3, 4 и 5.


```r
3:5
```

```
[1] 3 4 5
```

Если мы его напишем в квадратных скобках, то добудем элементы с такими порядковыми номерами


```r
vect_num[3:5]
```

```
[1] -9 -8 -7
```

---

## Выбор элементов из вектора

Аналогично, если вам нужны элементы не подряд, то передайте вектор с номерами элементов, который вы создали при помощи функции c() c(2, 4, 6) \# это вектор содержащий 2, 4 и 6, поэтому


```r
vect_num[c(2, 4, 6)] # возвращает 2-й, 4-й и 6-й элементы
```

```
[1] -10  -8  -6
```

```r
vect_num[c(1, 10, 20)] # возвращает 1-й, 10-й и 20-й элементы
```

```
[1] -11  -2   8
```

Вектор - одномерный объект. У его элементов только один порядковый номер (индекс). Поэтому при обращении к элементам вектора нужно указывать только одно число или один вектор с адресами.

Правильно:


```r
vect_num[c(1, 2, 5)] # возвращает 1-й, 3-й и 5-й элементы
```

```
[1] -11 -10  -7
```

---

## Выбор элементов из вектора

R выдаёт ошибку, если при обращении к вектору просто перечислить номера элементов через запятую.


```r
vect_num[1, 3, 5] # ошибка
vect_num[15, 9, 1] # ошибка
```


```r
vect_num[c(15, 9, 1)] # правильно
```

```
[1]   3  -3 -11
```

При помощи функции c() можно объединять несколько векторов в один вектор


```r
c(1, 1, 5:9)
```

```
[1] 1 1 5 6 7 8 9
```

```r
c(vect_num, vect_num)
```

```
 [1] -11 -10  -9  -8  -7  -6  -5  -4  -3  -2  -1   0   1   2   3   4   5   6   7   8
[21]   9  10  11  12 -11 -10  -9  -8  -7  -6  -5  -4  -3  -2  -1   0   1   2   3   4
[41]   5   6   7   8   9  10  11  12
```

```r
c(100, vect_num)
```

```
 [1] 100 -11 -10  -9  -8  -7  -6  -5  -4  -3  -2  -1   0   1   2   3   4   5   6   7
[21]   8   9  10  11  12
```

Добываем 1, 3, 5 и с 22 по 24 элементы


```r
vect_num[c(1, 3, 5, 22:24)]
```

```
[1] -11  -9  -7  10  11  12
```

---

class: middle, center, inverse

# Типы данных в R

---

## Числовые данные

Всё, что вы видели в прошлом разделе :)

---

## Текстовые данные

Каждый текстовый элемент (говорят "строка" - string или character) должен быть окружен кавычками --- двойными или одинарными.


```r
"это текст"
```

```
[1] "это текст"
```

```r
'это тоже текст'
```

```
[1] "это тоже текст"
```

Текстовые значения можно объединять в вектора. Так получается текстовый вектор.


```r
rainbow &lt;- c("red", "orange", "yellow", "green", "blue", "violet")
rainbow # весь вектор
```

```
[1] "red"    "orange" "yellow" "green"  "blue"   "violet"
```

---

## Объединение векторов

Добываем первый и последний элементы.

Точно знаем, что элементов 6 в данном случае.


```r
rainbow[c(1, 6)]
```

```
[1] "red"    "violet"
```

Добываем элементы с 3 по 6.

Если у вас вдруг слишком короткий вектор в этом задании, то можно склеить новый из двух.


```r
double_rainbow &lt;- c(rainbow, rainbow)
double_rainbow
```

```
 [1] "red"    "orange" "yellow" "green"  "blue"   "violet" "red"    "orange" "yellow"
[10] "green"  "blue"   "violet"
```

```r
rainbow[3:6] # элементы с 3 по 6
```

```
[1] "yellow" "green"  "blue"   "violet"
```

---

## Логические данные


```r
TRUE # истина
```

```
[1] TRUE
```

```r
FALSE # ложь
```

```
[1] FALSE
```

Можно сокращать первыми заглавными буквами. **Но лучше так не делать**, чтобы читать программы было легче.


```r
c(T, T, T, T, F, F, T, T)
```

```
[1]  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE
```

Создаём логический вектор.


```r
c(TRUE, TRUE, TRUE, FALSE, FALSE, TRUE)
```

```
[1]  TRUE  TRUE  TRUE FALSE FALSE  TRUE
```

Ещё логический вектор


```r
short_logical_vector &lt;- c(FALSE, TRUE)
```

---

## Длинные векторы

Чтобы создавать длинные вектора из повторяющихся элементов, можно использовать функцию rep().


```r
rep(x = 1, times = 3) # 1 повторяется 3 раза
```

```
[1] 1 1 1
```

```r
rep(x = "red", times = 5) # "red" повторяется 5 раз
```

```
[1] "red" "red" "red" "red" "red"
```

```r
rep(x = TRUE, times = 2) # TRUE повторяется 2 раза
```

```
[1] TRUE TRUE
```

---

## Аргументы функций 

В R названия аргументов функций можно не указывать, если вы используете аргументы порядке, прописанном в help к этой функции.


```r
rep(TRUE, 5) # TRUE повторяется 5 раз, аргументы без названий
```

```
[1] TRUE TRUE TRUE TRUE TRUE
```

Создаем логический вектор, где TRUE повторяется 3 раза, FALSE 3 раза и TRUE 4 раза. Результат сохраняем в переменной vect_log


```r
vect_log &lt;- c(rep(TRUE, 3), rep(FALSE, 3), rep(TRUE, 4))
vect_log
```

```
 [1]  TRUE  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE
```

---

## Применение логических векторов для фильтрации данных

Логические векторы создаются при проверке выполнения каких-либо условий, заданных при помощи логических операторов (`&gt;`, `&lt;`, `==`, `!=`, `&gt;=`, `&lt;=`, `!`, `&amp;`, `|`). Такие векторы можно использовать для фильтрации данных.

Вспомните, у нас был вот такой текстовый вектор.


```r
double_rainbow
```

```
 [1] "red"    "orange" "yellow" "green"  "blue"   "violet" "red"    "orange" "yellow"
[10] "green"  "blue"   "violet"
```

---

## Задача 1. 

Извлекаем только .yellow[жёлтый] цвет.

Мы можем создать логический вектор, в котором TRUE будет только для 3-го и 9-го элементов.


```r
f_yellow &lt;- double_rainbow == "yellow"
f_yellow
```

```
 [1] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE
```

Этот логический вектор-фильтр мы можем использовать для извлечения данных из `double_rainbow`


```r
double_rainbow[f_yellow]
```

```
[1] "yellow" "yellow"
```

---

## Задача 2. 

Извлекаем из double_rainbow .yellow[жёлтый] и .blue[синий]. Жёлтый фильтр у нас уже есть, поэтому мы создадим фильтр для синего.


```r
f_blue &lt;- double_rainbow == "blue"
```

Выражение "жёлтый или синий" можно записать при помощи логического "или" (`|`)


```r
f_yellow | f_blue
```

```
 [1] FALSE FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE
```

Задача решена, мы извлекли жёлтый и синий цвета.


```r
double_rainbow[f_yellow | f_blue]
```

```
[1] "yellow" "blue"   "yellow" "blue"  
```

---

## Сокращаем запись

То же самое можно было бы записать короче.

В одну строку --- совершенно нечитабельно:


```r
double_rainbow[double_rainbow == "yellow" | double_rainbow == "blue"]
```

```
[1] "yellow" "blue"   "yellow" "blue"  
```

Фильтр отдельно --- читается лучше:


```r
f_colours &lt;- double_rainbow == "yellow" | double_rainbow == "blue"
double_rainbow[f_colours]
```

```
[1] "yellow" "blue"   "yellow" "blue"  
```

---

## Задача 3

Был числовой вектор.


```r
vect_num
```

```
 [1] -11 -10  -9  -8  -7  -6  -5  -4  -3  -2  -1   0   1   2   3   4   5   6   7   8
[21]   9  10  11  12
```

Извлекаем из числового вектора `vect_num` только значения больше 0.


```r
vect_num[vect_num &gt; 0]
```

```
 [1]  1  2  3  4  5  6  7  8  9 10 11 12
```

**Задача 4**. Давайте извлечем из вектора `vect_num` все числа, которые либо меньше или равны -8, либо больше или равны 8


```r
f_5_8 &lt;- (vect_num &lt;= -8) | (vect_num &gt;= 8)
vect_num[f_5_8]
```

```
[1] -11 -10  -9  -8   8   9  10  11  12
```

---

## Факторы

Факторы --- это способ хранения дискретных (= категориальных данных). Факторы построены на основе целочисленных векторов и имеют несколько атрибутов (`class` и `level`).

Например, если вы поймали 10 улиток и посмотрели их цвет. У большого количества улиток небольшое счетное количество возможных цветов.


```r
snail_colours &lt;- c("red", "green", "green", "green", "yellow", "yellow", "yellow", "yellow")
snail_colours # это текстовый вектор
```

```
[1] "red"    "green"  "green"  "green"  "yellow" "yellow" "yellow" "yellow"
```

Цвет "жёлтый" обозначает одно и то же для каждой из улиток. Поэтому в целях экономии места можно записать цвета этих улиток в виде вектора, в котором численным значениям будут сопоставлены "этикетки" (называются "уровни", levels) --- названия цветов. Мы можем создать фактор "цвет улиток".

---

## Создаём фактор 


```r
factor(snail_colours)
```

```
[1] red    green  green  green  yellow yellow yellow yellow
Levels: green red yellow
```

уровни этого фактора

-   1 --- green,
-   2 --- red,
-   3 --- yellow.

По умолчанию, R назначает порядок уровней по алфавиту. Можно изменить порядок (см. `help("factor")`). Нам это пригодится позже.


```r
double_rainbow # текстовый вектор
```

```
 [1] "red"    "orange" "yellow" "green"  "blue"   "violet" "red"    "orange" "yellow"
[10] "green"  "blue"   "violet"
```

Создаем фактор из текстового вектора и складываем его в переменную


```r
f_double_rainbow &lt;- factor(double_rainbow)
```

---

## Как узнать, что за данные хранятся в переменной?

Чтобы узнать, что за данные хранятся в переменной, используйте функцию `class()`


```r
class(f_double_rainbow)
```

```
[1] "factor"
```

```r
class(vect_log)
```

```
[1] "logical"
```

```r
class(vect_num)
```

```
[1] "integer"
```

```r
class(rainbow)
```

```
[1] "character"
```

---

## Встроенные константы в R

Встроенные константы в R: NA, NULL, NAN, Inf

-   NA -- англ "not available". Когда объект был, но его свойство не измерили или не записали.
-   NULL -- пусто - просто ничего нет
-   NaN -- "not a number"
-   Inf -- "infinity" - бесконечность

Вот текстовый вектор с пропущенным значением


```r
rainbow_1 &lt;- c("red", "orange", NA, "green", "blue", "violet")
```

---

Что будет, если попытаться добыть из вектор номер элемента, которого там нет? 

--

R выдаст NA, потому, что такого элемента нет.


```r
rainbow_1[198]
```

```
[1] NA
```

---

## Арифметические операции с векторами


```r
vect_num
```

```
 [1] -11 -10  -9  -8  -7  -6  -5  -4  -3  -2  -1   0   1   2   3   4   5   6   7   8
[21]   9  10  11  12
```

```r
vect_num + 2
```

```
 [1] -9 -8 -7 -6 -5 -4 -3 -2 -1  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14
```

```r
vect_num * 2
```

```
 [1] -22 -20 -18 -16 -14 -12 -10  -8  -6  -4  -2   0   2   4   6   8  10  12  14  16
[21]  18  20  22  24
```

```r
vect_num * (-2)
```

```
 [1]  22  20  18  16  14  12  10   8   6   4   2   0  -2  -4  -6  -8 -10 -12 -14 -16
[21] -18 -20 -22 -24
```

```r
vect_num^2
```

```
 [1] 121 100  81  64  49  36  25  16   9   4   1   0   1   4   9  16  25  36  49  64
[21]  81 100 121 144
```

---

## Операции с векторами, содержащими константы


```r
NAs_NANs &lt;- c(1, 3, NA, 7, 0, 22:24)
```

Что произойдет с NA?


```r
NAs_NANs + 2 # останется NA
```

```
[1]  3  5 NA  9  2 24 25 26
```

```r
NAs_NANs * 0 # останется NA
```

```
[1]  0  0 NA  0  0  0  0  0
```

```r
NAs_NANs / 0  # останется NA
```

```
[1] Inf Inf  NA Inf NaN Inf Inf Inf
```

*Но в последнем случае вы увидите:*

-   Inf при делении чисел на ноль;
-   NaN при делении нуля на ноль.

NaN получится, если взять корень из отрицательного числа


```r
sqrt(-1)
```

```
[1] NaN
```

---

## Функции в R

Вы уже видели массу функций, их легко узнать по скобкам после ключевого слова. Познакомимся еще с несколькими и научимся писать пользовательские функции. Пользовательские функции позволяют автоматизировать повторяющиеся действия и делают код легко читаемым.

Вот наш вектор


```r
NAs_NANs
```

```
[1]  1  3 NA  7  0 22 23 24
```

Длину вектора можно вычислить при помощи функции `length()`


```r
length(NAs_NANs)
```

```
[1] 8
```

Сумму элементов вектора при помощи функции `sum()`


```r
sum(NAs_NANs)
```

```
[1] NA
```

Упс! Почему-то получилось `NA`.

---

## Работа функций с векторами, содержащими константы

У функции `sum()` есть аргумент `na.rm`, который по умолчанию принимает значение `FALSE`, то есть `NA` не учитываются при подсчете суммы.

Если мы передадим функции `sum` аргумент `na.rm = TRUE`, то получится правильная сумма


```r
sum(NAs_NANs, na.rm = TRUE)
```

```
[1] 80
```

Та же история с функцией `mean`


```r
mean(NAs_NANs, na.rm = TRUE)
```

```
[1] 11.43
```

---

## Пользовательские функции

Попробуем написать пользовательскую функцию `mmean()`, которая будет по умолчанию считать среднее значение элементов в векторе с учетом пропущенных значений (`NA`)


```r
mmean &lt;- function(x){
  mean(x, na.rm = TRUE)
  }
```

В этом коде: - mmean - переменная, название функции. В эту переменную мы складываем функцию, которую создает функция `function()` --- функция, которая делает функции. В скобках перечисляются аргументы (названия переменных, которые мы передаем в функцию, чтобы она что-то сделала с ними) - `{ }` - в фигурных скобках тело функции - последовательность действий, которую нужно сделать с аргументами

---

## Return в теле функции

У больших функций бывает еще инструкция `return()`, которая сообщает, что именно должна возвращать наша функция. Вот как выглядела бы наша функция с этой инструкцией.


```r
mmean &lt;- function(x){
  res &lt;- mean(x, na.rm = TRUE)
  return(res)
}
```

Проверим нашу функцию при помощи встроенной функции


```r
mean(vect_num, na.rm = TRUE)
```

```
[1] 0.5
```

```r
mmean(vect_num)
```

```
[1] 0.5
```

---

## Матрицы 

Матрицы --- двумерный объект, схожий с атомарными векторами, но содержащий дополнительный аттрибут `dim`. 

Матрицу можно создать следующим образом:


```r
matrix(1:9, nrow = 3, ncol = 3)
```

```
     [,1] [,2] [,3]
[1,]    1    4    7
[2,]    2    5    8
[3,]    3    6    9
```

Размерность матрицы создаётся двумя аргументами: `nrow` (количество строк) и `ncol` (количество столбцов). 

---

## Датафреймы --- двумерные структуры данных

Датафрейм --- один из способов хранения табличных данных в R.  Строится на базе списков и имеет в т.ч. сходные с матрицами свойства. Имеет такие атрибуты как `rownames` (имена строк) и `colnames` (имена столбцов). `names` датафрейма идентичны `colnames`. 

Создадим датафрейм. Для начала создадим векторы с данными для переменных.


```r
len &lt;- 1:9 # числовой
col &lt;- c(rep("green", 4), rep("red", 5)) # текстовый
wid &lt;- seq(from = 2, by = 2, to = 18) # числовой
```

Теперь сложим эти векторы в датафрейм


```r
my_worms &lt;- data.frame(Length = len, Width = wid, Colour = col, stringsAsFactors = TRUE)
```

Можно проверить, действительно мы создали объект класса data.frame


```r
class(my_worms) # смотрим, действительно датафрейм
```

```
[1] "data.frame"
```

---

## Превращение других типов данных в датафрейм

Например, из матрицы...


```r
mat &lt;- matrix(1:9, nrow = 3, ncol = 3)
mat_data &lt;- as.data.frame(mat)
str(mat_data)
```

```
'data.frame':	3 obs. of  3 variables:
 $ V1: int  1 2 3
 $ V2: int  4 5 6
 $ V3: int  7 8 9
```

---

## Содержимое датафрейма

Содержимое датафрейма можно посмотреть несколькими способами.


```r
my_worms # печать датафрейма
View(my_worms) # просмотр в RStudio
head(my_worms)
tail(my_worms)
# fix(my_worms) # ручное редактирование. осторожно! избегайте его использовать, никаких документов о нем не останется
```

Также у датафрейма можно посмотреть количество строк и столбцов.


```r
nrow(my_worms)
```

```
[1] 9
```

```r
ncol(my_worms)
```

```
[1] 3
```

```r
length(my_worms) #выдаст количество столбцов
```

```
[1] 3
```

---

## Адресация внутри датафреймов

Вывод столбца-переменной при помощи оператора \$ и имени переменной


```r
my_worms$Length
```

```
[1] 1 2 3 4 5 6 7 8 9
```

```r
my_worms$Width
```

```
[1]  2  4  6  8 10 12 14 16 18
```

У каждой ячейки в датафрейме есть координаты вида [строка, столбец]


```r
my_worms[2, 3] # вторая строка в 3 столбце
```

```
[1] green
Levels: green red
```

```r
my_worms[2, ] # вторая строка целиком
```

```
  Length Width Colour
2      2     4  green
```

```r
my_worms[1:9, 2] # строки с 1 по 9 во втором столбце
```

```
[1]  2  4  6  8 10 12 14 16 18
```

```r
my_worms[, 2] # второй столбец целиком
```

```
[1]  2  4  6  8 10 12 14 16 18
```

---

## Расширение датафрейма

Добавление колонки.


```r
my_worms$Site &lt;- c("Sredniy", "Sredniy", "Ogorod", "Vichennaya", "Ogorod", "Vichennaya", "Keret", "Ogorod", "Vichennaya")
my_worms
```

```
  Length Width Colour       Site
1      1     2  green    Sredniy
2      2     4  green    Sredniy
3      3     6  green     Ogorod
4      4     8  green Vichennaya
5      5    10    red     Ogorod
6      6    12    red Vichennaya
7      7    14    red      Keret
8      8    16    red     Ogorod
9      9    18    red Vichennaya
```

---

## Добавление строки


```r
my_worms_new &lt;- data.frame(Length = 40, Width = 60, Colour = "blue", Site = "Pashinnikov")
my_worms_final &lt;- rbind(my_worms, my_worms_new)
my_worms_final
```

```
   Length Width Colour        Site
1       1     2  green     Sredniy
2       2     4  green     Sredniy
3       3     6  green      Ogorod
4       4     8  green  Vichennaya
5       5    10    red      Ogorod
6       6    12    red  Vichennaya
7       7    14    red       Keret
8       8    16    red      Ogorod
9       9    18    red  Vichennaya
10     40    60   blue Pashinnikov
```

    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="assets/macros.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "vs",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>
<!-- https://github.com/fnaufel/xaringan-smartify-->
<script type="text/javascript">
  smartify();
</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
