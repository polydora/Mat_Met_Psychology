# Добашнее задание 3 - Описательная статистика
# Авакян Кристина
# Группа: ББ5А23/10

# ==================================================================
# Часть 1. Статистика
#
# Вариант 1. Переменная Petal.Length для каждого из видов из датасета iris
# ==================================================================

# Открываем датасет iris
data(iris)

# Все ли правильно открылось?
head(iris)
str(iris)

# Есть ли пропущенные значения и что это за случаи (если есть)?
# sum(! complete.cases(iris))
# iris[! complete.cases(iris), ]

# Загружаем пакет dplyr
library(dplyr)

# Используем конвейер и выодим статистику по iris
iris %>%
  group_by(Species) %>% # Группируем по типу sp
  summarise(Min = min(Petal.Length),                    # Минимум
            Max = max(Petal.Length),                    # Максимум
            Q1 = quantile(Petal.Length, probs = 0.25),  # 1й квартиль
            Median = median(Petal.Length),              # Медиана
            Q3 = quantile(Petal.Length, probs = 0.75))  # 3й квартиль

# ==================================================================
# Часть 2. График типа boxplot
# ==================================================================

# Загружаем пакет ggplot2
library(ggplot2)

# Устанавливаем тему
theme_set(theme_bw())

# Используем конвейер и формируем график
iris %>%
  ggplot(aes(y = Petal.Length, x = Species)) +
  geom_boxplot(color = "black", fill = "grey") +
  labs(x = "Species", y = "Значение Petal.Length") +
  ggtitle(label = "Анализ датасета Iris (Авакян)",
          subtitle = "Описательная статистика") -> plot_iris_boxplot

# Показываем график
plot_iris_boxplot
  
# Сохраняем график
# ggsave("Images/Avakian_Iris_Boxplot.jpg", plot = plot_iris_boxplot)

# ==================================================================
# Часть 3. Проверка на нормальность распределения
# ==================================================================

# Загружаем данные из файла
dataset <- read.table("data/dataset_variant_1.csv",
                      header = TRUE, sep = ";")


# ## Все ли правильно открылось?
head(dataset)
str(dataset)

# При необходимости сначала проверяем есть ли пропущенные значения?
# sum(! complete.cases(dataset))

# ==================================================================
# 3.1 Построим графически распределения всех пяти перменных,
#     чтобы оценить распределения на первом этапе визуально
# ==================================================================

# Загружаем пакеты tidyr и ggplot2
library(tidyr)
library(ggplot2)

# Делаем длинный формат данных
dataset %>%
  pivot_longer(cols = starts_with("Var"),
               names_to = "Variable",
               values_to = "Value") -> dataset_long

# Заранее задаем цвета для всех графиков
colors = c(Var1 = "red",
           Var2 = "orange",
           Var3 = "yellow",
           Var4 = "green",
           Var5 = "cyan")

# Создаем график распределений
dataset_long %>%
  ggplot(aes(x = Value, fill = Variable)) +     # Основной слой графика
  geom_histogram(bins = 30, color = "black") +  # Гистограмма
  facet_wrap(~ Variable, scales = "free") +     # Разбиваем на отдельные графики
  scale_fill_manual(values = colors) +          # Устанавливаем цвет
  labs(title = "Распределения переменных", x = "Значение", y = "Частота") -> plot_hist_vars

# Показываем графики распределений
plot_hist_vars

# Сохраняем график
# ggsave("Images/Avakian_Vars_Histograms.jpg", plot = plot_hist_vars)

# Визуально видно, что
#   Var1: Близко к нормальнору распределению
#   Var2: Похоже на бинормальное распределение (2 пика)
#   Var3: Асимметричное распределение
#   Var4: Асимметричное распределеник
#   Var5: Асимметричное распределение

# ==================================================================
# 3.2 Проведем корректную оценку на основе
#     сопоставления квантилей стандартизованного нормального
#     распределения и наблюдаемого распределения
#
#     Построим квартильные графики
# ==================================================================

# Загружаем пакет car
library(car)

# Устанавливаем разметку холста (1, 2)
par(mfrow = c(1, 2))

# Строим группу квантильных графиков
hist(dataset$Var1, nclass = 30, main = '', col = colors["Var1"])
qqPlot(dataset$Var1, id = FALSE, col = colors["Var1"], pch = 19) # Переменная Var1

# - Var1 -
# Распределение НЕ является нормальным распределением, т.к.
# по квантильному графику видно, что края распределения выходят за 
# допустимые рамки, кривизна ярко выражена

hist(dataset$Var2, nclass = 30, main = '', col = colors["Var2"])
qqPlot(dataset$Var2, id = FALSE, col = colors["Var2"], pch = 19) # Переменная Var2

# - Var2 -
# Распределение НЕ является нормальным распределением, т.к.
# по квантильному графику видно, что кривая имеет S-образную форму и
# не лежит на прямой

hist(dataset$Var3, nclass = 30, main = '', col = colors["Var3"])
qqPlot(dataset$Var3, id = FALSE, col = colors["Var3"], pch = 19) # Переменная Var3

# - Var3 -
# Распределение НЕ является нормальным распределением, т.к.
# по квантильному графику видно, что края распределения выходят за 
# допустимые рамки, кривизна ярко выражена

hist(dataset$Var4, nclass = 30, main = '', col = colors["Var4"])
qqPlot(dataset$Var4, id = FALSE, col = colors["Var4"], pch = 19) # Переменная Var4

# - Var4 -
# Распределение МОЖНО СЧИТАТЬ нормальным распределением, т.к.
# по квантильному графику видно, что точки центральной части лежат на прямой, 
# а края не выходят за допустимые рамки

hist(dataset$Var5, nclass = 30, main = '', col = colors["Var5"])
qqPlot(dataset$Var5, id = FALSE, col = colors["Var5"], pch = 19) # Переменная Var5

# - Var5 -
# Распределение НЕ является нормальным распределением, т.к.
# по квантильному графику видно, что края распределения выходят за 
# допустимые рамки, кривизна ярко выражена

# Возвращаем разметку холста
par(mfrow = c(1, 1))

# ==================================================================
# ОТВЕТ: Нормальному распределению подчиняется переменная Var4
# ==================================================================

# ==================================================================
# Часть 4. Вычисление выборочных средних и
#          среднеквадратичных отклонений 
#
# Вариант 1. Переменная Petal.Length для каждого из видов из датасета iris
# ==================================================================

# Загружаем пакет dplyr
library(dplyr)

# Вычисляем средние и стандартные отклонения по группам Species
iris %>%
  group_by(Species) %>%
  summarise(Petal.Length_mean = mean(Petal.Length),
            Petal.Length_sd   = sd(Petal.Length)) -> iris_summary

# Установим для повторяемости
set.seed(12345)

# Параметры выборки и их количество
sample_size <- 20 # Установим размер выборки (число наблюдений)
n_samples <- 3    # Количество повторных выборок

# Создаем пустой датафрейм
iris_samples_df <- data.frame(Sample = integer(0),
                              Species = character(0),
                              Mean = numeric(0),
                              SD = numeric(0))

# Разделяем данные по видам
iris_split <- split(iris$Petal.Length, iris$Species)

# Начинаем вычисления
for(species in names(iris_split)){                            # Цикл по видам растений
  for(i in 1:n_samples){                                      # Цикл n_samples раз (чтобы было n_samples выборок) 
    smpl <- sample(iris_split[[species]], size = sample_size) # Берем выборку размером sample_size
    mean_value <- mean(smpl)                                  # Вычисляем выборочное среднее
    sd_value <- sd(smpl)                                      # Вычисляем среднеквадратичное отклонение
    iris_samples_df <- rbind(iris_samples_df,
                             data.frame(N_Sample = i,            # Номер выборки (для наглядности)
                                        Species = species,       # Вид растения
                                        Sample_Size = n_samples, # Размер выборки (число наблюдений) для вида
                                        Mean = mean_value,       # Выборочное среднее
                                        SD = sd_value))          # Выборочное среднекв. отклонение
    }
}

# Смотрим результат
iris_samples_df  # n_samples выборочных средних для выборок размером sample_size
iris_summary     # Выводим общую статистику для наглядности и сравнения

# ==================================================================
# Часть 5. Определение границ 95% доверительного интервала (ДИ)
#          для каждой из категорий датасета iris
# ==================================================================

# Так как мы вычислили выборочное среднее и среднеквадратичное отклонение m-раз
# Для вычисления доверительно интервала мы можем взять или одно любое значение, для каждого вида,
# либо также выполнить вычисление ДИ для всех m-выборок

# Загружаем пакет dplyr
library(dplyr)

# Берем датафрейм и перезаписываем в него дополнительные переменные (Size, SE, t, CI)
iris_samples_df <- iris_samples_df %>%
  group_by(Species) %>%
  mutate(
    t = qt(p = 0.975, df = sample_size - 1),   # t-критическое значение для 95% ДИ, нужно p = (0.025, 0.975)
    SE = SD / sqrt(sample_size),               # Cтандартная ошибка
    CI_lower = Mean - t * SE,                  # нижняя граница ДИ
    CI_upper = Mean + t * SE                   # верхняя граница ДИ
  )

# Смотрим результат
iris_samples_df  # ДИ для m выборочных средних с размером выборок n
iris_summary     # Выводим общую статистику для наглядности и сравнения
